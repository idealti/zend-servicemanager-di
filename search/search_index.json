{
    "docs": [
        {
            "location": "/",
            "text": "zend-servicemanager-di\n\n\n\n\n\n\nProvides integration for \nzend-di\n\nwithin \nzend-servicemanager\n\n\n\n\nFile issues at https://github.com/zendframework/zend-servicemanager-di/issues\n\n\nDocumentation is at https://docs.zendframework.com/zend-servicemanager-di/",
            "title": "zend-servicemanager-di"
        },
        {
            "location": "/#zend-servicemanager-di",
            "text": "Provides integration for  zend-di \nwithin  zend-servicemanager   File issues at https://github.com/zendframework/zend-servicemanager-di/issues  Documentation is at https://docs.zendframework.com/zend-servicemanager-di/",
            "title": "zend-servicemanager-di"
        },
        {
            "location": "/services/",
            "text": "Services Provided\n\n\nzend-servicemanager-di provides a number of factories and services that\nintegrate \nzend-di\n into\n\nzend-servicemanager\n.\nThe following lists each, and details:\n\n\n\n\nwhether or not they are registered by default; and\n\n\nhow to enable them if not.\n\n\n\n\nDiFactory\n\n\nZend\\ServiceManager\\Di\\DiFactory\n creates and returns a \nZend\\Di\\Di\n instance.\nIf the \nconfig\n service is present, and contains a top-level \ndi\n key, the value\nof that key will be used to seed a \nZend\\Di\\Config\n instance, which will then in\nturn be used to configure the \nDi\n instance.\n\n\nBy default, this factory is mapped to the service name \nDependencyInjector\n, and\naliased to \nDi\n.\n\n\nConfiguration for the service should follow the rules for\n\nZend\\Di\\Config\n.\n\n\nDiServiceFactory\n\n\nZend\\ServiceManager\\Di\\DiServiceFactory\n provides a zend-di-backed factory that\nwill use the name provided and attempt to create the relevant object instance.\n\n\nThe constructor accepts three arguments:\n\n\n\n\n$di\n, a \nZend\\Di\\Di\n instance.\n\n\n$useContainer\n, one of the class constants \nUSE_SL_BEFORE_DI\n,\n  \nUSE_SL_AFTER_DI\n, \nUSE_SL_NONE\n, as detailed below.\n\n\n\n\nThe factory composes the \nDi\n instance, and uses the \n$useContainer\n value to\ndetermine how to attempt to create the instance, according to the following\nrules:\n\n\n\n\nIf \nUSE_SL_BEFORE_DI\n is provided, the factory will attempt to fetch the service\n  from the passed container first, and fall back to the composed DI container\n  only on failure.\n\n\nIf \nUSE_SL_AFTER_DI\n is provided, the factory will attempt to fetch the service\n  from the composed DI container first, and fall back to the passed container\n  only on failure.\n\n\nIf \nUSE_SL_NONE\n is provided (or no argument is passed), then the factory will\n  only fetch from the composed DI container.\n\n\n\n\nWhile you can use the factory directly, doing so requires seeding it with a\nconfigured \nDi\n instance. In most cases, you will use the\n\nDiAbstractServiceFactory\n instead, as detailed in the next section.\n\n\nDiAbstractServiceFactory\n\n\nZend\\ServiceManager\\Di\\DiAbstractServiceFactory\n provides an \nabstract\nfactory\n\nthat will, on invocation, pull the requested class from the composed\n\nZend\\Di\\Di\n instance. It extends \nDiServiceFactory\n to provide the utilities\nnecessary to act as an abstract factory.\n\n\nWhen determining if a requested service can be created, it does the following,\nin the following order:\n\n\n\n\nChecks if a shared instance is already present for the requested service in\n  the DI instance manager.\n\n\nChecks if an alias exists for the requested service in the DI instance\n  manager.\n\n\nChecks if configuration exists for the requested service in the DI instance\n  manager.\n\n\nChecks if type preferences exist for the requested service in the DI instance\n  manager.\n\n\n\n\nIf none of the above return true, it then:\n\n\n\n\nchecks if a class definition exists for the requested service;\n\n\nchecks if the requested service is an interface name.\n\n\n\n\nIf none of the above return true, it will not attempt to create the requested\nservice.\n\n\nIf the service can be created, creation follows the rules outlined for the\n\nDiServiceFactory\n.\n\n\nDiAbstractServiceFactory\n is registered under the service name\n\nDiAbstractServiceFactory\n by default. To register it as an abstract factory in\nyour code, you will need to manually register it. This will typically be done\nvia one of your application modules, within the \nonBootstrap()\n method:\n\n\nclass Module\n{\n    public function onBootstrap($e)\n    {\n        $app = $e->getTarget();\n        $services = $app->getServiceManager();\n\n        $services->addAbstractFactory($services->get('DiAbstractServiceFactory'));\n    }\n}\n\n\n\nThis should typically be done in a module registered early, to ensure it happens\nbefore many services are pulled from the container.\n\n\nDiStrictAbstractServiceFactory\n\n\nZend\\ServiceManager\\Di\\DiStrictAbstractServiceFactory\n works similarly to\n\nDiAbstractServiceFactory\n and \nDiServiceFactory\n, with a few key differences.\n\n\nFirst, unlike \nDiAbstractServiceFactory\n, it directly extends \nZend\\Di\\Di\n; as\nsuch, it acts exactly like \nZend\\Di\\Di\n, except where it specifically overloads\nfunctionality. Second, it implements a \nwhitelist\n; if the requested class does\nnot exist in the whitelist, the abstract factory will not attempt to create an\ninstance. This latter is useful for creating a \nscoped\n \nDi\n instance. As an\nexample, when pulling controllers, you may be tempted to use a \n:controller\n\nsegment in your routing; having a whitelist ensures that if a user requests an\narbitrary classname for the controller, the abstract factory will not attempt to\ncreate an instance!\n\n\nDiStrictAbstractServiceFactory\n is registered under the service name\n\nDiStrictAbstractServiceFactory\n by default. To register it as an abstract factory in\nyour code, you will need to manually register it. This will typically be done\nvia one of your application modules, within the \nonBootstrap()\n method:\n\n\nclass Module\n{\n    public function onBootstrap($e)\n    {\n        $app = $e->getTarget();\n        $services = $app->getServiceManager();\n\n        $services->addAbstractFactory($services->get('DiStrictAbstractServiceFactory'));\n    }\n}\n\n\n\nThis should typically be done in a module registered early, to ensure it happens\nbefore many services are pulled from the container.\n\n\nBy default, \nDiStrictAbstractServiceFactory\n is consumed by\n\nZend\\Mvc\\Controller\\ControllerManager\n; if the abstract factory is detected, it\nis added as an abstract factory to the \nControllerManager\n instance.\n\n\nThsu, by default, the factory for building the \nDiStrictAbstractServiceFactory\n\ninstance checks for configuration under \ndi.allowed_controllers\n; this should\nbe an array of controller names to add to the service:\n\n\nreturn [\n    'di' => [\n        'allowed_controllers' => [\n            'Some\\Controller\\Name',\n        ],\n    ],\n];\n\n\n\nYou can use \nDiStrictAbstractServiceFactory\n in other locations as well, and\nwith other configuration. Consider using \ndelegator factories\n\nin order to seed the \nDiStrictAbstractServiceFactory\n:\n\n\npublic function __invoke(ContainerInterface $container, $name, callable $callback, array $options = null)\n{\n    $diStrictAbstractFactory = $callback();\n\n    $config = $container->has('config') ? $container->get('config') : [];\n\n    if (! isset($config['application_di_class_whitelist'])) {\n        return $diStrictAbstractFactory;\n    }\n\n    $diStrictAbstractFactory->setAllowedServiceNames($config['application_di_class_whitelist']);\n    return $diStrictAbstractFactory;\n}\n\n\n\nDiServiceInitializer\n\n\nZend\\ServiceManager\\Di\\DiServiceInitializer\n is a zend-servicemanager\n\ninitializer\n,\nand can be used to initialize instances after they've already been pulled from\nthe container. This functionality can work with invokable services, or to\naugment existing factories in your zend-servicemanager configuration.\n\n\nBecause the initializer requires a \nZend\\Di\\Di\n instance, as well as the parent\napplication container, it is registered with zend-servicemanager, and you will\nneed to retrieve it and add it as an initializer manually, typically in an\napplication module's \nonBootstrap()\n method:\n\n\nclass Module\n{\n    public function onBootstrap($e)\n    {\n        $app = $e->getTarget();\n        $services = $app->getServiceManager();\n\n        $services->addInitializer($services->get('DiServiceInitializer'));\n    }\n}\n\n\n\nWe do not recommend using this functionality, as initializers are run for every\nnew instance retrieved, and the functionality could conflict with existing\nfactories for services.",
            "title": "Services"
        },
        {
            "location": "/services/#services-provided",
            "text": "zend-servicemanager-di provides a number of factories and services that\nintegrate  zend-di  into zend-servicemanager .\nThe following lists each, and details:   whether or not they are registered by default; and  how to enable them if not.",
            "title": "Services Provided"
        },
        {
            "location": "/services/#difactory",
            "text": "Zend\\ServiceManager\\Di\\DiFactory  creates and returns a  Zend\\Di\\Di  instance.\nIf the  config  service is present, and contains a top-level  di  key, the value\nof that key will be used to seed a  Zend\\Di\\Config  instance, which will then in\nturn be used to configure the  Di  instance.  By default, this factory is mapped to the service name  DependencyInjector , and\naliased to  Di .  Configuration for the service should follow the rules for Zend\\Di\\Config .",
            "title": "DiFactory"
        },
        {
            "location": "/services/#diservicefactory",
            "text": "Zend\\ServiceManager\\Di\\DiServiceFactory  provides a zend-di-backed factory that\nwill use the name provided and attempt to create the relevant object instance.  The constructor accepts three arguments:   $di , a  Zend\\Di\\Di  instance.  $useContainer , one of the class constants  USE_SL_BEFORE_DI ,\n   USE_SL_AFTER_DI ,  USE_SL_NONE , as detailed below.   The factory composes the  Di  instance, and uses the  $useContainer  value to\ndetermine how to attempt to create the instance, according to the following\nrules:   If  USE_SL_BEFORE_DI  is provided, the factory will attempt to fetch the service\n  from the passed container first, and fall back to the composed DI container\n  only on failure.  If  USE_SL_AFTER_DI  is provided, the factory will attempt to fetch the service\n  from the composed DI container first, and fall back to the passed container\n  only on failure.  If  USE_SL_NONE  is provided (or no argument is passed), then the factory will\n  only fetch from the composed DI container.   While you can use the factory directly, doing so requires seeding it with a\nconfigured  Di  instance. In most cases, you will use the DiAbstractServiceFactory  instead, as detailed in the next section.",
            "title": "DiServiceFactory"
        },
        {
            "location": "/services/#diabstractservicefactory",
            "text": "Zend\\ServiceManager\\Di\\DiAbstractServiceFactory  provides an  abstract\nfactory \nthat will, on invocation, pull the requested class from the composed Zend\\Di\\Di  instance. It extends  DiServiceFactory  to provide the utilities\nnecessary to act as an abstract factory.  When determining if a requested service can be created, it does the following,\nin the following order:   Checks if a shared instance is already present for the requested service in\n  the DI instance manager.  Checks if an alias exists for the requested service in the DI instance\n  manager.  Checks if configuration exists for the requested service in the DI instance\n  manager.  Checks if type preferences exist for the requested service in the DI instance\n  manager.   If none of the above return true, it then:   checks if a class definition exists for the requested service;  checks if the requested service is an interface name.   If none of the above return true, it will not attempt to create the requested\nservice.  If the service can be created, creation follows the rules outlined for the DiServiceFactory .  DiAbstractServiceFactory  is registered under the service name DiAbstractServiceFactory  by default. To register it as an abstract factory in\nyour code, you will need to manually register it. This will typically be done\nvia one of your application modules, within the  onBootstrap()  method:  class Module\n{\n    public function onBootstrap($e)\n    {\n        $app = $e->getTarget();\n        $services = $app->getServiceManager();\n\n        $services->addAbstractFactory($services->get('DiAbstractServiceFactory'));\n    }\n}  This should typically be done in a module registered early, to ensure it happens\nbefore many services are pulled from the container.",
            "title": "DiAbstractServiceFactory"
        },
        {
            "location": "/services/#districtabstractservicefactory",
            "text": "Zend\\ServiceManager\\Di\\DiStrictAbstractServiceFactory  works similarly to DiAbstractServiceFactory  and  DiServiceFactory , with a few key differences.  First, unlike  DiAbstractServiceFactory , it directly extends  Zend\\Di\\Di ; as\nsuch, it acts exactly like  Zend\\Di\\Di , except where it specifically overloads\nfunctionality. Second, it implements a  whitelist ; if the requested class does\nnot exist in the whitelist, the abstract factory will not attempt to create an\ninstance. This latter is useful for creating a  scoped   Di  instance. As an\nexample, when pulling controllers, you may be tempted to use a  :controller \nsegment in your routing; having a whitelist ensures that if a user requests an\narbitrary classname for the controller, the abstract factory will not attempt to\ncreate an instance!  DiStrictAbstractServiceFactory  is registered under the service name DiStrictAbstractServiceFactory  by default. To register it as an abstract factory in\nyour code, you will need to manually register it. This will typically be done\nvia one of your application modules, within the  onBootstrap()  method:  class Module\n{\n    public function onBootstrap($e)\n    {\n        $app = $e->getTarget();\n        $services = $app->getServiceManager();\n\n        $services->addAbstractFactory($services->get('DiStrictAbstractServiceFactory'));\n    }\n}  This should typically be done in a module registered early, to ensure it happens\nbefore many services are pulled from the container.  By default,  DiStrictAbstractServiceFactory  is consumed by Zend\\Mvc\\Controller\\ControllerManager ; if the abstract factory is detected, it\nis added as an abstract factory to the  ControllerManager  instance.  Thsu, by default, the factory for building the  DiStrictAbstractServiceFactory \ninstance checks for configuration under  di.allowed_controllers ; this should\nbe an array of controller names to add to the service:  return [\n    'di' => [\n        'allowed_controllers' => [\n            'Some\\Controller\\Name',\n        ],\n    ],\n];  You can use  DiStrictAbstractServiceFactory  in other locations as well, and\nwith other configuration. Consider using  delegator factories \nin order to seed the  DiStrictAbstractServiceFactory :  public function __invoke(ContainerInterface $container, $name, callable $callback, array $options = null)\n{\n    $diStrictAbstractFactory = $callback();\n\n    $config = $container->has('config') ? $container->get('config') : [];\n\n    if (! isset($config['application_di_class_whitelist'])) {\n        return $diStrictAbstractFactory;\n    }\n\n    $diStrictAbstractFactory->setAllowedServiceNames($config['application_di_class_whitelist']);\n    return $diStrictAbstractFactory;\n}",
            "title": "DiStrictAbstractServiceFactory"
        },
        {
            "location": "/services/#diserviceinitializer",
            "text": "Zend\\ServiceManager\\Di\\DiServiceInitializer  is a zend-servicemanager initializer ,\nand can be used to initialize instances after they've already been pulled from\nthe container. This functionality can work with invokable services, or to\naugment existing factories in your zend-servicemanager configuration.  Because the initializer requires a  Zend\\Di\\Di  instance, as well as the parent\napplication container, it is registered with zend-servicemanager, and you will\nneed to retrieve it and add it as an initializer manually, typically in an\napplication module's  onBootstrap()  method:  class Module\n{\n    public function onBootstrap($e)\n    {\n        $app = $e->getTarget();\n        $services = $app->getServiceManager();\n\n        $services->addInitializer($services->get('DiServiceInitializer'));\n    }\n}  We do not recommend using this functionality, as initializers are run for every\nnew instance retrieved, and the functionality could conflict with existing\nfactories for services.",
            "title": "DiServiceInitializer"
        },
        {
            "location": "/migration/v2-to-v3/",
            "text": "Migration: From zend-mvc v2 DI/ServiceManager integration\n\n\nzend-servicemanager-di ports all DI integration present in:\n\n\n\n\nzend-servicemanager\n, and\n\n\nzend-mvc\n\n\n\n\nto a single, optional component. As such, a number of classes were renamed that\nmay impact end-users.\n\n\nzend-servicemanager functionality\n\n\nThe following classes were originally in zend-servicemanager, but are now\nshipped as part of this package:\n\n\n\n\nZend\\ServiceManager\\Di\\DiAbstractServiceFactory\n\n\nZend\\ServiceManager\\Di\\DiInstanceManagerProxy\n\n\nZend\\ServiceManager\\Di\\DiServiceFactory\n\n\nZend\\ServiceManager\\Di\\DiServiceInitializer\n\n\n\n\nSome functionality was altered slightly to allow usage under both\nzend-servicemanager v2 and v3, including how instance names and\ninstance-specific parameters are handled.\n\n\nDiServiceFactory\n\n\nThe constructor was changed to remove the \n$name\n and \n$parameters\n arguments.\nThese are now passed at invocation of the factory instead, making it perform\nmore correctly with relation to other \nFactoryInterface\n implementations.\n\n\nzend-mvc functionality\n\n\nThe following classes were renamed:\n\n\n\n\nZend\\Mvc\\Service\\DiAbstractServiceFactoryFactory\n was renamed to\n  \nZend\\ServiceManager\\Di\\DiAbstractServiceFactoryFactory\n.\n\n\nZend\\Mvc\\Service\\DiServiceInitializerFactory\n was renamed to\n  \nZend\\ServiceManager\\Di\\DiServiceInitializerFactory\n.\n\n\nZend\\Mvc\\Service\\DiFactory\n was renamed to\n  \nZend\\ServiceManager\\Di\\DiFactory\n.\n\n\nZend\\Mvc\\Service\\DiStrictAbstractServiceFactory\n was renamed to\n  \nZend\\ServiceManager\\Di\\DiStrictAbstractServiceFactory\n\n\nZend\\Mvc\\Service\\DiStrictAbstractServiceFactoryFactory\n was renamed to\n  \nZend\\ServiceManager\\Di\\DiStrictAbstractServiceFactoryFactory\n\n\n\n\nAll of the above are registered under service names identical to those used in\nv2 versions of zend-mvc, meaning no change in usage for the majority of use\ncases.",
            "title": "Version 2 to Version 3"
        },
        {
            "location": "/migration/v2-to-v3/#migration-from-zend-mvc-v2-diservicemanager-integration",
            "text": "zend-servicemanager-di ports all DI integration present in:   zend-servicemanager , and  zend-mvc   to a single, optional component. As such, a number of classes were renamed that\nmay impact end-users.",
            "title": "Migration: From zend-mvc v2 DI/ServiceManager integration"
        },
        {
            "location": "/migration/v2-to-v3/#zend-servicemanager-functionality",
            "text": "The following classes were originally in zend-servicemanager, but are now\nshipped as part of this package:   Zend\\ServiceManager\\Di\\DiAbstractServiceFactory  Zend\\ServiceManager\\Di\\DiInstanceManagerProxy  Zend\\ServiceManager\\Di\\DiServiceFactory  Zend\\ServiceManager\\Di\\DiServiceInitializer   Some functionality was altered slightly to allow usage under both\nzend-servicemanager v2 and v3, including how instance names and\ninstance-specific parameters are handled.",
            "title": "zend-servicemanager functionality"
        },
        {
            "location": "/migration/v2-to-v3/#diservicefactory",
            "text": "The constructor was changed to remove the  $name  and  $parameters  arguments.\nThese are now passed at invocation of the factory instead, making it perform\nmore correctly with relation to other  FactoryInterface  implementations.",
            "title": "DiServiceFactory"
        },
        {
            "location": "/migration/v2-to-v3/#zend-mvc-functionality",
            "text": "The following classes were renamed:   Zend\\Mvc\\Service\\DiAbstractServiceFactoryFactory  was renamed to\n   Zend\\ServiceManager\\Di\\DiAbstractServiceFactoryFactory .  Zend\\Mvc\\Service\\DiServiceInitializerFactory  was renamed to\n   Zend\\ServiceManager\\Di\\DiServiceInitializerFactory .  Zend\\Mvc\\Service\\DiFactory  was renamed to\n   Zend\\ServiceManager\\Di\\DiFactory .  Zend\\Mvc\\Service\\DiStrictAbstractServiceFactory  was renamed to\n   Zend\\ServiceManager\\Di\\DiStrictAbstractServiceFactory  Zend\\Mvc\\Service\\DiStrictAbstractServiceFactoryFactory  was renamed to\n   Zend\\ServiceManager\\Di\\DiStrictAbstractServiceFactoryFactory   All of the above are registered under service names identical to those used in\nv2 versions of zend-mvc, meaning no change in usage for the majority of use\ncases.",
            "title": "zend-mvc functionality"
        }
    ]
}